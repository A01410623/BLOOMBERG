# -*- coding: utf-8 -*-
"""Actividad Clase Bloomberg.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1wRg1_JNV6WZri1XzvioZtjBmvK1dwf8L
"""

# Import required libraries
import pandas as pd
import numpy as np
from google.colab import files
import statsmodels.api as sm
from statsmodels.tsa.stattools import adfuller, kpss
from statsmodels.tsa.arima.model import ARIMA
from statsmodels.tsa.vector_ar.vecm import coint_johansen
import matplotlib.pyplot as plt

# Dictionary to store file information
files_info = {
    'AMZN_1MIN': 'AMZN 1 MIN 1 DIA',
    'AMZN_3MIN': 'AMZN 3 MIN 1 DIA',
    'MSFT_1MIN': 'MSFT 1 MIN 1 DIA',
    'MSFT_3MIN': 'MSFT 3 MIN 1 DIA',
    'NIKE_1MIN': 'NIKE 1 MIN 1 DIA',
    'NIKE_3MIN': 'NIKE 3 MIN 1 DIA'
}

# Upload Excel files and load data
dataframes = {}
for key, name in files_info.items():
    print(f"Please upload {name} Excel file")
    uploaded = files.upload()
    filename = list(uploaded.keys())[0]
    df = pd.read_excel(filename)
    dataframes[key] = df
    print(f"{name} columns:", list(df.columns))

# Ask user for the closing price column name
close_column = input("Please enter the column name containing closing prices (e.g., 'Close'): ")

# Extract and clean closing prices
close_prices = {}
for key, df in dataframes.items():
    try:
        # Extract the column (fixed typo: Df -> df)
        series = df[close_column]
        # Convert to numeric, coercing errors to NaN
        series = pd.to_numeric(series, errors='coerce')
        # Drop NaN values
        series = series.dropna()
        if len(series) == 0:
            print(f"Error: No valid numeric data in {close_column} for {files_info[key]} after cleaning")
            raise ValueError(f"Empty series for {files_info[key]}")
        close_prices[key] = series
    except KeyError:
        print(f"Error: Column '{close_column}' not found in {files_info[key]}")
        raise

# Ensure all series have the same length
min_length = min(len(series) for series in close_prices.values())
for key in close_prices:
    close_prices[key] = close_prices[key][:min_length]

# Plot historical prices (1-minute and 3-minute separately)
plt.figure(figsize=(12,6))
plt.plot(close_prices['AMZN_1MIN'], label='AMZN 1-min')
plt.plot(close_prices['MSFT_1MIN'], label='MSFT 1-min')
plt.plot(close_prices['NIKE_1MIN'], label='NIKE 1-min')
plt.title('Historical Closing Prices (1-Minute Data)')
plt.legend()
plt.show()

plt.figure(figsize=(12,6))
plt.plot(close_prices['AMZN_3MIN'], label='AMZN 3-min')
plt.plot(close_prices['MSFT_3MIN'], label='MSFT 3-min')
plt.plot(close_prices['NIKE_3MIN'], label='NIKE 3-min')
plt.title('Historical Closing Prices (3-Minute Data)')
plt.legend()
plt.show()

# Compute differenced series
diff_prices = {key: series.diff().dropna() for key, series in close_prices.items()}

# Plot differenced series
plt.figure(figsize=(12,6))
for key, series in diff_prices.items():
    plt.plot(series, label=f'{files_info[key]} Diff')
plt.title('Differenced Closing Prices')
plt.legend()
plt.show()

# Function for unit root tests with interpretation
def unit_root_tests(series, name):
    print(f"\nUnit Root Tests for {name}:")

    # ADF Test
    try:
        adf_result = adfuller(series)
        print("ADF Test:")
        print(f'ADF Statistic: {adf_result[0]:.4f}')
        print(f'p-value: {adf_result[1]:.4f}')
        print(f'Critical Values: {adf_result[4]}')
        print("Interpretation:")
        if adf_result[1] < 0.05:
            print(f"  - p-value < 0.05: Reject null hypothesis - {name} is stationary")
        else:
            print(f"  - p-value >= 0.05: Fail to reject null - {name} may be non-stationary")
    except ValueError as e:
        print(f"ADF Test failed for {name}: {e}")

    # KPSS Test
    try:
        kpss_result = kpss(series, regression='c')
        print("\nKPSS Test:")
        print(f'KPSS Statistic: {kpss_result[0]:.4f}')
        print(f'p-value: {kpss_result[1]:.4f}')
        print(f'Critical Values: {kpss_result[3]}')
        print("Interpretation:")
        if kpss_result[1] < 0.05:
            print(f"  - p-value < 0.05: Reject null hypothesis - {name} is non-stationary")
        else:
            print(f"  - p-value >= 0.05: Fail to reject null - {name} may be stationary")
    except ValueError as e:
        print(f"KPSS Test failed for {name}: {e}")

# Perform unit root tests for all series
for key, series in close_prices.items():
    unit_root_tests(series, files_info[key])

# Function to find best ARIMA model with interpretation
def find_best_arima(series, name, max_p=3, max_d=2, max_q=3):
    best_aic = float('inf')
    best_order = None

    for p in range(max_p + 1):
        for d in range(max_d + 1):
            for q in range(max_q + 1):
                try:
                    model = ARIMA(series, order=(p, d, q))
                    results = model.fit()
                    if results.aic < best_aic:
                        best_aic = results.aic
                        best_order = (p, d, q)
                except:
                    continue

    if best_order is None:
        print(f"\nNo valid ARIMA model found for {name}")
        return None
    print(f"\nBest ARIMA model for {name}:")
    print(f"Order: {best_order}")
    print(f"AIC: {best_aic:.2f}")
    print("Interpretation:")
    print(f"  - p={best_order[0]}: {best_order[0]} autoregressive term(s)")
    print(f"  - d={best_order[1]}: {best_order[1]} difference(s) needed for stationarity")
    print(f"  - q={best_order[2]}: {best_order[2]} moving average term(s)")
    return best_order

# Find and fit best ARIMA models
arima_orders = {}
arima_models = {}
for key, series in close_prices.items():
    order = find_best_arima(series, files_info[key])
    if order:
        arima_orders[key] = order
        arima_models[key] = ARIMA(series, order=order).fit()
    else:
        arima_models[key] = None

# Cointegration test for AMZN, MSFT, NIKE (using 1-minute data)
def cointegration_test(df):
    try:
        result = coint_johansen(df, det_order=0, k_ar_diff=1)
        print("\nJohansen Cointegration Test (AMZN, MSFT, NIKE):")
        print(f"Trace statistic: {result.lr1}")
        print(f"Critical values (90%, 95%, 99%): {result.cvt}")
        print("Interpretation:")
        for i in range(len(result.lr1)):
            if result.lr1[i] > result.cvt[i, 1]:
                print(f"  - r = {i}: Cointegration exists at 95% confidence level")
                print(f"    Trace statistic ({result.lr1[i]:.2f}) > 95% critical value ({result.cvt[i, 1]:.2f})")
            else:
                print(f"  - r = {i}: No cointegration at 95% confidence level")
                print(f"    Trace statistic ({result.lr1[i]:.2f}) <= 95% critical value ({result.cvt[i, 1]:.2f})")
        if result.lr1[0] > result.cvt[0, 1]:
            print("Conclusion: AMZN, MSFT, and NIKE are cointegrated - they share a long-run equilibrium relationship")
        else:
            print("Conclusion: No evidence of cointegration between AMZN, MSFT, and NIKE")
    except ValueError as e:
        print(f"Cointegration test failed: {e}")

# Prepare data for cointegration (using 1-minute data)
coint_df = pd.DataFrame({
    'AMZN': close_prices['AMZN_1MIN'],
    'MSFT': close_prices['MSFT_1MIN'],
    'NIKE': close_prices['NIKE_1MIN']
}).dropna()
cointegration_test(coint_df)

# Pairwise cointegration plot
plt.figure(figsize=(12,8))
plt.subplot(3,1,1)
plt.plot(close_prices['AMZN_1MIN'], label='AMZN 1-min')
plt.plot(close_prices['MSFT_1MIN'], label='MSFT 1-min')
plt.title('AMZN vs MSFT (1-Minute Data)')
plt.legend()
plt.subplot(3,1,2)
plt.plot(close_prices['AMZN_1MIN'], label='AMZN 1-min')
plt.plot(close_prices['NIKE_1MIN'], label='NIKE 1-min')
plt.title('AMZN vs NIKE (1-Minute Data)')
plt.legend()
plt.subplot(3,1,3)
plt.plot(close_prices['MSFT_1MIN'], label='MSFT 1-min')
plt.plot(close_prices['NIKE_1MIN'], label='NIKE 1-min')
plt.title('MSFT vs NIKE (1-Minute Data)')
plt.legend()
plt.tight_layout()
plt.show()

# Forecast next 30 periods
forecast_steps = 30
forecasts = {}
for key, model in arima_models.items():
    if model:
        forecasts[key] = model.forecast(steps=forecast_steps)
    else:
        forecasts[key] = None
        print(f"No forecast generated for {files_info[key]} due to model fitting failure")

# Create forecast index
last_index = min_length - 1
forecast_index = range(last_index + 1, last_index + 1 + forecast_steps)

# Plot original series with forecasts (1-minute data)
plt.figure(figsize=(12,6))
if 'AMZN_1MIN' in close_prices:
    plt.plot(close_prices['AMZN_1MIN'], label='AMZN 1-min Historical')
    if forecasts['AMZN_1MIN'] is not None:
        plt.plot(forecast_index, forecasts['AMZN_1MIN'], label='AMZN 1-min Forecast', color='red')
if 'MSFT_1MIN' in close_prices:
    plt.plot(close_prices['MSFT_1MIN'], label='MSFT 1-min Historical')
    if forecasts['MSFT_1MIN'] is not None:
        plt.plot(forecast_index, forecasts['MSFT_1MIN'], label='MSFT 1-min Forecast', color='green')
if 'NIKE_1MIN' in close_prices:
    plt.plot(close_prices['NIKE_1MIN'], label='NIKE 1-min Historical')
    if forecasts['NIKE_1MIN'] is not None:
        plt.plot(forecast_index, forecasts['NIKE_1MIN'], label='NIKE 1-min Forecast', color='blue')
plt.title('AMZN, MSFT, NIKE 1-Min Closing Prices with Forecasts')
plt.legend()
plt.show()

# Detailed forecast plot with confidence intervals and interpretation
def plot_forecast(model, series, name, steps=30):
    if model is None:
        print(f"Cannot plot forecast for {name}: No valid model")
        return
    forecast_obj = model.get_forecast(steps=steps)
    forecast = forecast_obj.predicted_mean
    conf_int = forecast_obj.conf_int()

    forecast_index = range(len(series), len(series) + steps)

    plt.figure(figsize=(12,6))
    plt.plot(series, label=f'{name} Historical')
    plt.plot(forecast_index, forecast, label='Forecast', color='red')
    plt.fill_between(forecast_index,
                    conf_int.iloc[:, 0],
                    conf_int.iloc[:, 1],
                    color='pink',
                    alpha=0.3,
                    label='95% Confidence Interval')
    plt.title(f'{name} Price Forecast')
    plt.legend()
    plt.show()

    # Forecast interpretation
    last_value = series.iloc[-1]
    mean_forecast = forecast.mean()
    print(f"\nForecast Interpretation for {name}:")
    print(f"Last observed value: {last_value:.2f}")
    print(f"Average forecast value: {mean_forecast:.2f}")
    print(f"Forecast change: {mean_forecast - last_value:.2f}")
    if mean_forecast > last_value:
        print("Trend: Upward forecast trend")
    elif mean_forecast < last_value:
        print("Trend: Downward forecast trend")
    else:
        print("Trend: Flat forecast trend")
    print(f"95% CI range at period {steps}: [{conf_int.iloc[-1, 0]:.2f}, {conf_int.iloc[-1, 1]:.2f}]")

# Generate detailed forecast plots for all series
for key in arima_models:
    plot_forecast(arima_models[key], close_prices[key], files_info[key])

# Plot original series with forecasts (3-minute data)
plt.figure(figsize=(12,6))
if 'AMZN_3MIN' in close_prices:
    plt.plot(close_prices['AMZN_3MIN'], label='AMZN 3-min Historical')
    if forecasts['AMZN_3MIN'] is not None:
        plt.plot(forecast_index, forecasts['AMZN_3MIN'], label='AMZN 3-min Forecast', color='red')
if 'MSFT_3MIN' in close_prices:
    plt.plot(close_prices['MSFT_3MIN'], label='MSFT 3-min Historical')
    if forecasts['MSFT_3MIN'] is not None:
        plt.plot(forecast_index, forecasts['MSFT_3MIN'], label='MSFT 3-min Forecast', color='green')
if 'NIKE_3MIN' in close_prices:
    plt.plot(close_prices['NIKE_3MIN'], label='NIKE 3-min Historical')
    if forecasts['NIKE_3MIN'] is not None:
        plt.plot(forecast_index, forecasts['NIKE_3MIN'], label='NIKE 3-min Forecast', color='blue')
plt.title('AMZN, MSFT, NIKE 3-Min Closing Prices with Forecasts')
plt.legend()
plt.show()

# Print forecast values (first 5 periods)
for key in forecasts:
    if forecasts[key] is not None:
        print(f"\n{files_info[key]} Forecast Values (next 5 periods):")
        print(forecasts[key][:5])
    else:
        print(f"\n{files_info[key]}: No forecast values available")

# Import required libraries
import pandas as pd
import numpy as np
from google.colab import files
import statsmodels.api as sm
from statsmodels.tsa.stattools import adfuller, kpss
from statsmodels.tsa.arima.model import ARIMA
from statsmodels.tsa.vector_ar.vecm import coint_johansen
import matplotlib.pyplot as plt

# Dictionary to store file information
files_info = {
    'AMZN_1MIN': 'AMZN 1 MIN 1 DIA',
    'AMZN_3MIN': 'AMZN 3 MIN 1 DIA',
    'MSFT_1MIN': 'MSFT 1 MIN 1 DIA',
    'MSFT_3MIN': 'MSFT 3 MIN 1 DIA',
    'NIKE_1MIN': 'NIKE 1 MIN 1 DIA',
    'NIKE_3MIN': 'NIKE 3 MIN 1 DIA'
}

# Upload Excel files and load data
dataframes = {}
for key, name in files_info.items():
    print(f"Please upload {name} Excel file")
    uploaded = files.upload()
    filename = list(uploaded.keys())[0]
    df = pd.read_excel(filename)
    dataframes[key] = df
    print(f"{name} columns:", list(df.columns))

# Ask user for the closing price column name
close_column = input("Please enter the column name containing closing prices (e.g., 'Close'): ")

# Extract and clean closing prices
close_prices = {}
for key, df in dataframes.items():
    try:
        # Extract the column
        series = df[close_column]
        # Convert to numeric, coercing errors to NaN
        series = pd.to_numeric(series, errors='coerce')
        # Drop NaN values
        series = series.dropna()
        if len(series) == 0:
            print(f"Error: No valid numeric data in {close_column} for {files_info[key]} after cleaning")
            raise ValueError(f"Empty series for {files_info[key]}")
        close_prices[key] = series
    except KeyError:
        print(f"Error: Column '{close_column}' not found in {files_info[key]}")
        raise

# Ensure all series have the same length
min_length = min(len(series) for series in close_prices.values())
for key in close_prices:
    close_prices[key] = close_prices[key][:min_length]

# Plot historical prices (1-minute and 3-minute separately)
plt.figure(figsize=(12,6))
plt.plot(close_prices['AMZN_1MIN'], label='AMZN 1-min')
plt.plot(close_prices['MSFT_1MIN'], label='MSFT 1-min')
plt.plot(close_prices['NIKE_1MIN'], label='NIKE 1-min')
plt.title('Historical Closing Prices (1-Minute Data)')
plt.legend()
plt.show()

plt.figure(figsize=(12,6))
plt.plot(close_prices['AMZN_3MIN'], label='AMZN 3-min')
plt.plot(close_prices['MSFT_3MIN'], label='MSFT 3-min')
plt.plot(close_prices['NIKE_3MIN'], label='NIKE 3-min')
plt.title('Historical Closing Prices (3-Minute Data)')
plt.legend()
plt.show()

# Compute differenced series
diff_prices = {key: series.diff().dropna() for key, series in close_prices.items()}

# Plot differenced series
plt.figure(figsize=(12,6))
for key, series in diff_prices.items():
    plt.plot(series, label=f'{files_info[key]} Diff')
plt.title('Differenced Closing Prices')
plt.legend()
plt.show()

# Function for unit root tests with interpretation
def unit_root_tests(series, name):
    print(f"\nUnit Root Tests for {name}:")

    # ADF Test
    try:
        adf_result = adfuller(series)
        print("ADF Test:")
        print(f'ADF Statistic: {adf_result[0]:.4f}')
        print(f'p-value: {adf_result[1]:.4f}')
        print(f'Critical Values: {adf_result[4]}')
        print("Interpretation:")
        if adf_result[1] < 0.05:
            print(f"  - p-value < 0.05: Reject null hypothesis - {name} is stationary")
        else:
            print(f"  - p-value >= 0.05: Fail to reject null - {name} may be non-stationary")
    except ValueError as e:
        print(f"ADF Test failed for {name}: {e}")

    # KPSS Test
    try:
        kpss_result = kpss(series, regression='c')
        print("\nKPSS Test:")
        print(f'KPSS Statistic: {kpss_result[0]:.4f}')
        print(f'p-value: {kpss_result[1]:.4f}')
        print(f'Critical Values: {kpss_result[3]}')
        print("Interpretation:")
        if kpss_result[1] < 0.05:
            print(f"  - p-value < 0.05: Reject null hypothesis - {name} is non-stationary")
        else:
            print(f"  - p-value >= 0.05: Fail to reject null - {name} may be stationary")
    except ValueError as e:
        print(f"KPSS Test failed for {name}: {e}")

# Perform unit root tests for all series
for key, series in close_prices.items():
    unit_root_tests(series, files_info[key])

# Function to find best ARIMA model with interpretation
def find_best_arima(series, name, max_p=3, max_d=2, max_q=3):
    best_aic = float('inf')
    best_order = None

    for p in range(max_p + 1):
        for d in range(max_d + 1):
            for q in range(max_q + 1):
                try:
                    model = ARIMA(series, order=(p, d, q))
                    results = model.fit()
                    if results.aic < best_aic:
                        best_aic = results.aic
                        best_order = (p, d, q)
                except:
                    continue

    if best_order is None:
        print(f"\nNo valid ARIMA model found for {name}")
        return None
    print(f"\nBest ARIMA model for {name}:")
    print(f"Order: {best_order}")
    print(f"AIC: {best_aic:.2f}")
    print("Interpretation:")
    print(f"  - p={best_order[0]}: {best_order[0]} autoregressive term(s)")
    print(f"  - d={best_order[1]}: {best_order[1]} difference(s) needed for stationarity")
    print(f"  - q={best_order[2]}: {best_order[2]} moving average term(s)")
    return best_order

# Find and fit best ARIMA models
arima_orders = {}
arima_models = {}
for key, series in close_prices.items():
    order = find_best_arima(series, files_info[key])
    if order:
        arima_orders[key] = order
        arima_models[key] = ARIMA(series, order=order).fit()
    else:
        arima_models[key] = None

# Cointegration test for AMZN, MSFT, NIKE (using 1-minute data)
def cointegration_test(df):
    try:
        result = coint_johansen(df, det_order=0, k_ar_diff=1)
        print("\nJohansen Cointegration Test (AMZN, MSFT, NIKE):")
        print(f"Trace statistic: {result.lr1}")
        print(f"Critical values (90%, 95%, 99%): {result.cvt}")
        print("Interpretation:")
        for i in range(len(result.lr1)):
            if result.lr1[i] > result.cvt[i, 1]:
                print(f"  - r = {i}: Cointegration exists at 95% confidence level")
                print(f"    Trace statistic ({result.lr1[i]:.2f}) > 95% critical value ({result.cvt[i, 1]:.2f})")
            else:
                print(f"  - r = {i}: No cointegration at 95% confidence level")
                print(f"    Trace statistic ({result.lr1[i]:.2f}) <= 95% critical value ({result.cvt[i, 1]:.2f})")
        if result.lr1[0] > result.cvt[0, 1]:
            print("Conclusion: AMZN, MSFT, and NIKE are cointegrated - they share a long-run equilibrium relationship")
        else:
            print("Conclusion: No evidence of cointegration between AMZN, MSFT, and NIKE")
    except ValueError as e:
        print(f"Cointegration test failed: {e}")

# Prepare data for cointegration (using 1-minute data)
coint_df = pd.DataFrame({
    'AMZN': close_prices['AMZN_1MIN'],
    'MSFT': close_prices['MSFT_1MIN'],
    'NIKE': close_prices['NIKE_1MIN']
}).dropna()
cointegration_test(coint_df)

# Pairwise cointegration plot
plt.figure(figsize=(12,8))
plt.subplot(3,1,1)
plt.plot(close_prices['AMZN_1MIN'], label='AMZN 1-min')
plt.plot(close_prices['MSFT_1MIN'], label='MSFT 1-min')
plt.title('AMZN vs MSFT (1-Minute Data)')
plt.legend()
plt.subplot(3,1,2)
plt.plot(close_prices['AMZN_1MIN'], label='AMZN 1-min')
plt.plot(close_prices['NIKE_1MIN'], label='NIKE 1-min')
plt.title('AMZN vs NIKE (1-Minute Data)')
plt.legend()
plt.subplot(3,1,3)
plt.plot(close_prices['MSFT_1MIN'], label='MSFT 1-min')
plt.plot(close_prices['NIKE_1MIN'], label='NIKE 1-min')
plt.title('MSFT vs NIKE (1-Minute Data)')
plt.legend()
plt.tight_layout()
plt.show()

# Forecast next 30 periods
forecast_steps = 30
forecasts = {}
for key, model in arima_models.items():
    if model:
        forecasts[key] = model.forecast(steps=forecast_steps)
    else:
        forecasts[key] = None
        print(f"No forecast generated for {files_info[key]} due to model fitting failure")

# Create forecast index
last_index = min_length - 1
forecast_index = range(last_index + 1, last_index + 1 + forecast_steps)

# Plot original series with forecasts (1-minute data, log scale)
plt.figure(figsize=(12,6))
if 'AMZN_1MIN' in close_prices:
    plt.plot(close_prices['AMZN_1MIN'], label='AMZN 1-min Historical')
    if forecasts['AMZN_1MIN'] is not None:
        plt.plot(forecast_index, forecasts['AMZN_1MIN'], label='AMZN 1-min Forecast', color='red')
if 'MSFT_1MIN' in close_prices:
    plt.plot(close_prices['MSFT_1MIN'], label='MSFT 1-min Historical')
    if forecasts['MSFT_1MIN'] is not None:
        plt.plot(forecast_index, forecasts['MSFT_1MIN'], label='MSFT 1-min Forecast', color='green')
if 'NIKE_1MIN' in close_prices:
    plt.plot(close_prices['NIKE_1MIN'], label='NIKE 1-min Historical')
    if forecasts['NIKE_1MIN'] is not None:
        plt.plot(forecast_index, forecasts['NIKE_1MIN'], label='NIKE 1-min Forecast', color='blue')
plt.title('AMZN, MSFT, NIKE 1-Min Closing Prices with Forecasts (Log Scale)')
plt.yscale('log')  # Set y-axis to log base 10
plt.legend()
plt.show()

# Detailed forecast plot with confidence intervals and interpretation
def plot_forecast(model, series, name, steps=30):
    if model is None:
        print(f"Cannot plot forecast for {name}: No valid model")
        return
    forecast_obj = model.get_forecast(steps=steps)
    forecast = forecast_obj.predicted_mean
    conf_int = forecast_obj.conf_int()

    # Ensure positive values for log scale
    if (series.min() <= 0) or (forecast.min() <= 0) or (conf_int.min().min() <= 0):
        print(f"Warning: Cannot use log scale for {name} due to non-positive values")
        return

    forecast_index = range(len(series), len(series) + steps)

    plt.figure(figsize=(12,6))
    plt.plot(series, label=f'{name} Historical')
    plt.plot(forecast_index, forecast, label='Forecast', color='red')
    plt.fill_between(forecast_index,
                    conf_int.iloc[:, 0],
                    conf_int.iloc[:, 1],
                    color='pink',
                    alpha=0.3,
                    label='95% Confidence Interval')
    plt.title(f'{name} Price Forecast (Log Scale)')
    plt.yscale('log')  # Set y-axis to log base 10
    plt.legend()
    plt.show()

    # Forecast interpretation
    last_value = series.iloc[-1]
    mean_forecast = forecast.mean()
    print(f"\nForecast Interpretation for {name}:")
    print(f"Last observed value: {last_value:.2f}")
    print(f"Average forecast value: {mean_forecast:.2f}")
    print(f"Forecast change: {mean_forecast - last_value:.2f}")
    if mean_forecast > last_value:
        print("Trend: Upward forecast trend")
    elif mean_forecast < last_value:
        print("Trend: Downward forecast trend")
    else:
        print("Trend: Flat forecast trend")
    print(f"95% CI range at period {steps}: [{conf_int.iloc[-1, 0]:.2f}, {conf_int.iloc[-1, 1]:.2f}]")

# Generate detailed forecast plots for all series
for key in arima_models:
    plot_forecast(arima_models[key], close_prices[key], files_info[key])

# Plot original series with forecasts (3-minute data, log scale)
plt.figure(figsize=(12,6))
if 'AMZN_3MIN' in close_prices:
    plt.plot(close_prices['AMZN_3MIN'], label='AMZN 3-min Historical')
    if forecasts['AMZN_3MIN'] is not None:
        plt.plot(forecast_index, forecasts['AMZN_3MIN'], label='AMZN 3-min Forecast', color='red')
if 'MSFT_3MIN' in close_prices:
    plt.plot(close_prices['MSFT_3MIN'], label='MSFT 3-min Historical')
    if forecasts['MSFT_3MIN'] is not None:
        plt.plot(forecast_index, forecasts['MSFT_3MIN'], label='MSFT 3-min Forecast', color='green')
if 'NIKE_3MIN' in close_prices:
    plt.plot(close_prices['NIKE_3MIN'], label='NIKE 3-min Historical')
    if forecasts['NIKE_3MIN'] is not None:
        plt.plot(forecast_index, forecasts['NIKE_3MIN'], label='NIKE 3-min Forecast', color='blue')
plt.title('AMZN, MSFT, NIKE 3-Min Closing Prices with Forecasts (Log Scale)')
plt.yscale('log')  # Set y-axis to log base 10
plt.legend()
plt.show()

# Print forecast values (first 5 periods)
for key in forecasts:
    if forecasts[key] is not None:
        print(f"\n{files_info[key]} Forecast Values (next 5 periods):")
        print(forecasts[key][:5])
    else:
        print(f"\n{files_info[key]}: No forecast values available")