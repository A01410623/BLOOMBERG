<script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
        </script><!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ACTIVIDAD CLASE BLOOMBERG - Python Code</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }
        h1 {
            color: #333;
            text-align: center;
        }
        .code-container {
            background-color: #1e1e1e;
            color: #d4d4d4;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            max-width: 800px;
            margin: 0 auto;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        pre {
            margin: 0;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        code {
            font-family: 'Courier New', Courier, monospace;
            font-size: 14px;
            line-height: 1.5;
        }
        .comment {
            color: #6a9955;
        }
        .string {
            color: #ce9178;
        }
        .keyword {
            color: #569cd6;
        }
        .function {
            color: #dcdcaa;
        }
    </style>
</head>
<body>
    <h1>ACTIVIDAD CLASE BLOOMBERG - Python Code</h1>
    <div class="code-container">
        <pre><code>
<span class="comment"># -*- coding: utf-8 -*-</span>
<span class="string">"""ACTIVIDAD CLASE BLOOMBERG

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1pymr4BL6QvOC24PL4QNBTnpth6DXivxy
"""</span>

<span class="comment"># Import required libraries</span>
<span class="keyword">import</span> pandas <span class="keyword">as</span> pd
<span class="keyword">import</span> numpy <span class="keyword">as</span> np
<span class="keyword">from</span> google.colab <span class="keyword">import</span> files
<span class="keyword">import</span> statsmodels.api <span class="keyword">as</span> sm
<span class="keyword">from</span> statsmodels.tsa.stattools <span class="keyword">import</span> adfuller, kpss
<span class="keyword">from</span> statsmodels.tsa.arima.model <span class="keyword">import</span> ARIMA
<span class="keyword">from</span> statsmodels.tsa.vector_ar.vecm <span class="keyword">import</span> coint_johansen
<span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt

<span class="comment"># Dictionary to store file information</span>
files_info = {
    <span class="string">'TSLA_1MIN'</span>: <span class="string">'TSLA 1 MIN 1 DIA'</span>,
    <span class="string">'TSLA_3MIN'</span>: <span class="string">'TSLA 3 MIN 1 DIA'</span>,
    <span class="string">'NVDA_1MIN'</span>: <span class="string">'NVDA 1 MIN 1 DIA'</span>,
    <span class="string">'NVDA_3MIN'</span>: <span class="string">'NVDA 3 MIN 1 DIA'</span>,
    <span class="string">'AAPL_1MIN'</span>: <span class="string">'AAPL 1 MIN 1 DIA'</span>,
    <span class="string">'AAPL_3MIN'</span>: <span class="string">'AAPL 3 MIN 1 DIA'</span>
}

<span class="comment"># Upload Excel files and load data</span>
dataframes = {}
<span class="keyword">for</span> key, name <span class="keyword">in</span> files_info.items():
    print(<span class="string">f"Please upload {name} Excel file"</span>)
    uploaded = files.upload()
    filename = list(uploaded.keys())[0]
    df = pd.read_excel(filename)
    dataframes[key] = df
    print(<span class="string">f"{name} columns:"</span>, list(df.columns))

<span class="comment"># Ask user for the closing price column name</span>
close_column = input(<span class="string">"Please enter the column name containing closing prices (e.g., 'Close'): "</span>)

<span class="comment"># Extract and clean closing prices</span>
close_prices = {}
<span class="keyword">for</span> key, df <span class="keyword">in</span> dataframes.items():
    <span class="keyword">try</span>:
        <span class="comment"># Extract the column</span>
        series = df[close_column]
        <span class="comment"># Convert to numeric, coercing errors to NaN</span>
        series = pd.to_numeric(series, errors=<span class="string">'coerce'</span>)
        <span class="comment"># Drop NaN values</span>
        series = series.dropna()
        <span class="keyword">if</span> len(series) == 0:
            print(<span class="string">f"Error: No valid numeric data in {close_column} for {files_info[key]} after cleaning"</span>)
            <span class="keyword">raise</span> ValueError(<span class="string">f"Empty series for {files_info[key]}"</span>)
        close_prices[key] = series
    <span class="keyword">except</span> KeyError:
        print(<span class="string">f"Error: Column '{close_column}' not found in {files_info[key]}"</span>)
        <span class="keyword">raise</span>

<span class="comment"># Ensure all series have the same length</span>
min_length = min(len(series) <span class="keyword">for</span> series <span class="keyword">in</span> close_prices.values())
<span class="keyword">for</span> key <span class="keyword">in</span> close_prices:
    close_prices[key] = close_prices[key][:min_length]

<span class="comment"># Plot historical prices (1-minute and 3-minute separately)</span>
plt.figure(figsize=(12,6))
plt.plot(close_prices[<span class="string">'TSLA_1MIN'</span>], label=<span class="string">'TSLA 1-min'</span>)
plt.plot(close_prices[<span class="string">'NVDA_1MIN'</span>], label=<span class="string">'NVDA 1-min'</span>)
plt.plot(close_prices[<span class="string">'AAPL_1MIN'</span>], label=<span class="string">'AAPL 1-min'</span>)
plt.title(<span class="string">'Historical Closing Prices (1-Minute Data)'</span>)
plt.legend()
plt.show()

plt.figure(figsize=(12,6))
plt.plot(close_prices[<span class="string">'TSLA_3MIN'</span>], label=<span class="string">'TSLA 3-min'</span>)
plt.plot(close_prices[<span class="string">'NVDA_3MIN'</span>], label=<span class="string">'NVDA 3-min'</span>)
plt.plot(close_prices[<span class="string">'AAPL_3MIN'</span>], label=<span class="string">'AAPL 3-min'</span>)
plt.title(<span class="string">'Historical Closing Prices (3-Minute Data)'</span>)
plt.legend()
plt.show()

<span class="comment"># Compute differenced series</span>
diff_prices = {key: series.diff().dropna() <span class="keyword">for</span> key, series <span class="keyword">in</span> close_prices.items()}

<span class="comment"># Plot differenced series</span>
plt.figure(figsize=(12,6))
<span class="keyword">for</span> key, series <span class="keyword">in</span> diff_prices.items():
    plt.plot(series, label=<span class="string">f'{files_info[key]} Diff'</span>)
plt.title(<span class="string">'Differenced Closing Prices'</span>)
plt.legend()
plt.show()

<span class="comment"># Function for unit root tests with interpretation</span>
<span class="keyword">def</span> <span class="function">unit_root_tests</span>(series, name):
    print(<span class="string">f"\nUnit Root Tests for {name}:"</span>)

    <span class="comment"># ADF Test</span>
    <span class="keyword">try</span>:
        adf_result = adfuller(series)
        print(<span class="string">"ADF Test:"</span>)
        print(<span class="string">f'ADF Statistic: {adf_result[0]:.4f}'</span>)
        print(<span class="string">f'p-value: {adf_result[1]:.4f}'</span>)
        print(<span class="string">f'Critical Values: {adf_result[4]}'</span>)
        print(<span class="string">"Interpretation:"</span>)
        <span class="keyword">if</span> adf_result[1] < 0.05:
            print(<span class="string">f"  - p-value < 0.05: Reject null hypothesis - {name} is stationary"</span>)
        <span class="keyword">else</span>:
            print(<span class="string">f"  - p-value >= 0.05: Fail to reject null - {name} may be non-stationary"</span>)
    <span class="keyword">except</span> ValueError <span class="keyword">as</span> e:
        print(<span class="string">f"ADF Test failed for {name}: {e}"</span>)

    <span class="comment"># KPSS Test</span>
    <span class="keyword">try</span>:
        kpss_result = kpss(series, regression=<span class="string">'c'</span>)
        print(<span class="string">"\nKPSS Test:"</span>)
        print(<span class="string">f'KPSS Statistic: {kpss_result[0]:.4f}'</span>)
        print(<span class="string">f'p-value: {kpss_result[1]:.4f}'</span>)
        print(<span class="string">f'Critical Values: {kpss_result[3]}'</span>)
        print(<span class="string">"Interpretation:"</span>)
        <span class="keyword">if</span> kpss_result[1] < 0.05:
            print(<span class="string">f"  - p-value < 0.05: Reject null hypothesis - {name} is non-stationary"</span>)
        <span class="keyword">else</span>:
            print(<span class="string">f"  - p-value >= 0.05: Fail to reject null - {name} may be stationary"</span>)
    <span class="keyword">except</span> ValueError <span class="keyword">as</span> e:
        print(<span class="string">f"KPSS Test failed for {name}: {e}"</span>)

<span class="comment"># Perform unit root tests for all series</span>
<span class="keyword">for</span> key, series <span class="keyword">in</span> close_prices.items():
    unit_root_tests(series, files_info[key])

<span class="comment"># Function to find best ARIMA model with interpretation</span>
<span class="keyword">def</span> <span class="function">find_best_arima</span>(series, name, max_p=3, max_d=2, max_q=3):
    best_aic = float(<span class="string">'inf'</span>)
    best_order = None

    <span class="keyword">for</span> p <span class="keyword">in</span> range(max_p + 1):
        <span class="keyword">for</span> d <span class="keyword">in</span> range(max_d + 1):
            <span class="keyword">for</span> q <span class="keyword">in</span> range(max_q + 1):
                <span class="keyword">try</span>:
                    model = ARIMA(series, order=(p, d, q))
                    results = model.fit()
                    <span class="keyword">if</span> results.aic < best_aic:
                        best_aic = results.aic
                        best_order = (p, d, q)
                <span class="keyword">except</span>:
                    <span class="keyword">continue</span>

    <span class="keyword">if</span> best_order <span class="keyword">is</span> None:
        print(<span class="string">f"\nNo valid ARIMA model found for {name}"</span>)
        <span class="keyword">return</span> None
    print(<span class="string">f"\nBest ARIMA model for {name}:"</span>)
    print(<span class="string">f"Order: {best_order}"</span>)
    print(<span class="string">f"AIC: {best_aic:.2f}"</span>)
    print(<span class="string">"Interpretation:"</span>)
    print(<span class="string">f"  - p={best_order[0]}: {best_order[0]} autoregressive term(s)"</span>)
    print(<span class="string">f"  - d={best_order[1]}: {best_order[1]} difference(s) needed for stationarity"</span>)
    print(<span class="string">f"  - q={best_order[2]}: {best_order[2]} moving average term(s)"</span>)
    <span class="keyword">return</span> best_order

<span class="comment"># Find and fit best ARIMA models</span>
arima_orders = {}
arima_models = {}
<span class="keyword">for</span> key, series <span class="keyword">in</span> close_prices.items():
    order = find_best_arima(series, files_info[key])
    <span class="keyword">if</span> order:
        arima_orders[key] = order
        arima_models[key] = ARIMA(series, order=order).fit()
    <span class="keyword">else</span>:
        arima_models[key] = None

<span class="comment"># Cointegration test for TSLA, NVDA, AAPL (using 1-minute data)</span>
<span class="keyword">def</span> <span class="function">cointegration_test</span>(df):
    <span class="keyword">try</span>:
        result = coint_johansen(df, det_order=0, k_ar_diff=1)
        print(<span class="string">"\nJohansen Cointegration Test (TSLA, NVDA, AAPL):"</span>)
        print(<span class="string">f"Trace statistic: {result.lr1}"</span>)
        print(<span class="string">f"Critical values (90%, 95%, 99%): {result.cvt}"</span>)
        print(<span class="string">"Interpretation:"</span>)
        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(result.lr1)):
            <span class="keyword">if</span> result.lr1[i] > result.cvt[i, 1]:
                print(<span class="string">f"  - r = {i}: Cointegration exists at 95% confidence level"</span>)
                print(<span class="string">f"    Trace statistic ({result.lr1[i]:.2f}) > 95% critical value ({result.cvt[i, 1]:.2f})"</span>)
            <span class="keyword">else</span>:
                print(<span class="string">f"  - r = {i}: No cointegration at 95% confidence level"</span>)
                print(<span class="string">f"    Trace statistic ({result.lr1[i]:.2f}) <= 95% critical value ({result.cvt[i, 1]:.2f})"</span>)
        <span class="keyword">if</span> result.lr1[0] > result.cvt[0, 1]:
            print(<span class="string">"Conclusion: TSLA, NVDA, and AAPL are cointegrated - they share a long-run equilibrium relationship"</span>)
        <span class="keyword">else</span>:
            print(<span class="string">"Conclusion: No evidence of cointegration between TSLA, NVDA, and AAPL"</span>)
    <span class="keyword">except</span> ValueError <span class="keyword">as</span> e:
        print(<span class="string">f"Cointegration test failed: {e}"</span>)

<span class="comment"># Prepare data for cointegration (using 1-minute data)</span>
coint_df = pd.DataFrame({
    <span class="string">'TSLA'</span>: close_prices[<span class="string">'TSLA_1MIN'</span>],
    <span class="string">'NVDA'</span>: close_prices[<span class="string">'NVDA_1MIN'</span>],
    <span class="string">'AAPL'</span>: close_prices[<span class="string">'AAPL_1MIN'</span>]
}).dropna()
cointegration_test(coint_df)

<span class="comment"># Pairwise cointegration plot</span>
plt.figure(figsize=(12,8))
plt.subplot(3,1,1)
plt.plot(close_prices[<span class="string">'TSLA_1MIN'</span>], label=<span class="string">'TSLA 1-min'</span>)
plt.plot(close_prices[<span class="string">'NVDA_1MIN'</span>], label=<span class="string">'NVDA 1-min'</span>)
plt.title(<span class="string">'TSLA vs NVDA (1-Minute Data)'</span>)
plt.legend()
plt.subplot(3,1,2)
plt.plot(close_prices[<span class="string">'TSLA_1MIN'</span>], label=<span class="string">'TSLA 1-min'</span>)
plt.plot(close_prices[<span class="string">'AAPL_1MIN'</span>], label=<span class="string">'AAPL 1-min'</span>)
plt.title(<span class="string">'TSLA vs AAPL (1-Minute Data)'</span>)
plt.legend()
plt.subplot(3,1,3)
plt.plot(close_prices[<span class="string">'NVDA_1MIN'</span>], label=<span class="string">'NVDA 1-min'</span>)
plt.plot(close_prices[<span class="string">'AAPL_1MIN'</span>], label=<span class="string">'AAPL 1-min'</span>)
plt.title(<span class="string">'NVDA vs AAPL (1-Minute Data)'</span>)
plt.legend()
plt.tight_layout()
plt.show()

<span class="comment"># Forecast next 30 periods</span>
forecast_steps = 30
forecasts = {}
<span class="keyword">for</span> key, model <span class="keyword">in</span> arima_models.items():
    <span class="keyword">if</span> model:
        forecasts[key] = model.forecast(steps=forecast_steps)
    <span class="keyword">else</span>:
        forecasts[key] = None
        print(<span class="string">f"No forecast generated for {files_info[key]} due to model fitting failure"</span>)

<span class="comment"># Create forecast index</span>
last_index = min_length - 1
forecast_index = range(last_index + 1, last_index + 1 + forecast_steps)

<span class="comment"># Plot original series with forecasts (1-minute data, log scale)</span>
plt.figure(figsize=(12,6))
<span class="keyword">if</span> <span class="string">'TSLA_1MIN'</span> <span class="keyword">in</span> close_prices:
    plt.plot(close_prices[<span class="string">'TSLA_1MIN'</span>], label=<span class="string">'TSLA 1-min Historical'</span>)
    <span class="keyword">if</span> forecasts[<span class="string">'TSLA_1MIN'</span>] <span class="keyword">is</span> <span class="keyword">not</span> None:
        plt.plot(forecast_index, forecasts[<span class="string">'TSLA_1MIN'</span>], label=<span class="string">'TSLA 1-min Forecast'</span>, color=<span class="string">'red'</span>)
<span class="keyword">if</span> <span class="string">'NVDA_1MIN'</span> <span class="keyword">in</span> close_prices:
    plt.plot(close_prices[<span class="string">'NVDA_1MIN'</span>], label=<span class="string">'NVDA 1-min Historical'</span>)
    <span class="keyword">if</span> forecasts[<span class="string">'NVDA_1MIN'</span>] <span class="keyword">is</span> <span class="keyword">not</span> None:
        plt.plot(forecast_index, forecasts[<span class="string">'NVDA_1MIN'</span>], label=<span class="string">'NVDA 1-min Forecast'</span>, color=<span class="string">'green'</span>)
<span class="keyword">if</span> <span class="string">'AAPL_1MIN'</span> <span class="keyword">in</span> close_prices:
    plt.plot(close_prices[<span class="string">'AAPL_1MIN'</span>], label=<span class="string">'AAPL 1-min Historical'</span>)
    <span class="keyword">if</span> forecasts[<span class="string">'AAPL_1MIN'</span>] <span class="keyword">is</span> <span class="keyword">not</span> None:
        plt.plot(forecast_index, forecasts[<span class="string">'AAPL_1MIN'</span>], label=<span class="string">'AAPL 1-min Forecast'</span>, color=<span class="string">'blue'</span>)
plt.title(<span class="string">'TSLA, NVDA, AAPL 1-Min Closing Prices with Forecasts (Log Scale)'</span>)
plt.yscale(<span class="string">'log'</span>)  <span class="comment"># Set y-axis to log base 10</span>
plt.legend()
plt.show()

<span class="comment"># Detailed forecast plot with confidence intervals and interpretation</span>
<span class="keyword">def</span> <span class="function">plot_forecast</span>(model, series, name, steps=30):
    <span class="keyword">if</span> model <span class="keyword">is</span> None:
        print(<span class="string">f"Cannot plot forecast for {name}: No valid model"</span>)
        <span class="keyword">return</span>
    forecast_obj = model.get_forecast(steps=steps)
    forecast = forecast_obj.predicted_mean
    conf_int = forecast_obj.conf_int()

    <span class="comment"># Ensure positive values for log scale</span>
    <span class="keyword">if</span> (series.min() <= 0) <span class="keyword">or</span> (forecast.min() <= 0) <span class="keyword">or</span> (conf_int.min().min() <= 0):
        print(<span class="string">f"Warning: Cannot use log scale for {name} due to non-positive values"</span>)
        <span class="keyword">return</span>

    forecast_index = range(len(series), len(series) + steps)

    plt.figure(figsize=(12,6))
    plt.plot(series, label=<span class="string">f'{name} Historical'</span>)
    plt.plot(forecast_index, forecast, label=<span class="string">'Forecast'</span>, color=<span class="string">'red'</span>)
    plt.fill_between(forecast_index,
                    conf_int.iloc[:, 0],
                    conf_int.iloc[:, 1],
                    color=<span class="string">'pink'</span>,
                    alpha=0.3,
                    label=<span class="string">'95% Confidence Interval'</span>)
    plt.title(<span class="string">f'{name} Price Forecast (Log Scale)'</span>)
    plt.yscale(<span class="string">'log'</span>)  <span class="comment"># Set y-axis to log base 10</span>
    plt.legend()
    plt.show()

    <span class="comment"># Forecast interpretation</span>
    last_value = series.iloc[-1]
    mean_forecast = forecast.mean()
    print(<span class="string">f"\nForecast Interpretation for {name}:"</span>)
    print(<span class="string">f"Last observed value: {last_value:.2f}"</span>)
    print(<span class="string">f"Average forecast value: {mean_forecast:.2f}"</span>)
    print(<span class="string">f"Forecast change: {mean_forecast - last_value:.2f}"</span>)
    <span class="keyword">if</span> mean_forecast > last_value:
        print(<span class="string">"Trend: Upward forecast trend"</span>)
    <span class="keyword">elif</span> mean_forecast < last_value:
        print(<span class="string">"Trend: Downward forecast trend"</span>)
    <span class="keyword">else</span>:
        print(<span class="string">"Trend: Flat forecast trend"</span>)
    print(<span class="string">f"95% CI range at period {steps}: [{conf_int.iloc[-1, 0]:.2f}, {conf_int.iloc[-1, 1]:.2f}]"</span>)

<span class="comment"># Generate detailed forecast plots for all series</span>
<span class="keyword">for</span> key <span class="keyword">in</span> arima_models:
    plot_forecast(arima_models[key], close_prices[key], files_info[key])

<span class="comment"># Plot original series with forecasts (3-minute data, log scale)</span>
plt.figure(figsize=(12,6))
<span class="keyword">if</span> <span class="string">'TSLA_3MIN'</span> <span class="keyword">in</span> close_prices:
    plt.plot(close_prices[<span class="string">'TSLA_3MIN'</span>], label=<span class="string">'TSLA 3-min Historical'</span>)
    <span class="keyword">if</span> forecasts[<span class="string">'TSLA_3MIN'</span>] <span class="keyword">is</span> <span class="keyword">not</span> None:
        plt.plot(forecast_index, forecasts[<span class="string">'TSLA_3MIN'</span>], label=<span class="string">'TSLA 3-min Forecast'</span>, color=<span class="string">'red'</span>)
<span class="keyword">if</span> <span class="string">'NVDA_3MIN'</span> <span class="keyword">in</span> close_prices:
    plt.plot(close_prices[<span class="string">'NVDA_3MIN'</span>], label=<span class="string">'NVDA 3-min Historical'</span>)
    <span class="keyword">if</span> forecasts[<span class="string">'NVDA_3MIN'</span>] <span class="keyword">is</span> <span class="keyword">not</span> None:
        plt.plot(forecast_index, forecasts[<span class="string">'NVDA_3MIN'</span>], label=<span class="string">'NVDA 3-min Forecast'</span>, color=<span class="string">'green'</span>)
<span class="keyword">if</span> <span class="string">'AAPL_3MIN'</span> <span class="keyword">in</span> close_prices:
    plt.plot(close_prices[<span class="string">'AAPL_3MIN'</span>], label=<span class="string">'AAPL 3-min Historical'</span>)
    <span class="keyword">if</span> forecasts[<span class="string">'AAPL_3MIN'</span>] <span class="keyword">is</span> <span class="keyword">not</span> None:
        plt.plot(forecast_index, forecasts[<span class="string">'AAPL_3MIN'</span>], label=<span class="string">'AAPL 3-min Forecast'</span>, color=<span class="string">'blue'</span>)
plt.title(<span class="string">'TSLA, NVDA, AAPL 3-Min Closing Prices with Forecasts (Log Scale)'</span>)
plt.yscale(<span class="string">'log'</span>)  <span class="comment"># Set y-axis to log base 10</span>
plt.legend()
plt.show()

<span class="comment"># Print forecast values (first 5 periods)</span>
<span class="keyword">for</span> key <span class="keyword">in</span> forecasts:
    <span class="keyword">if</span> forecasts[key] <span class="keyword">is</span> <span class="keyword">not</span> None:
        print(<span class="string">f"\n{files_info[key]} Forecast Values (next 5 periods):"</span>)
        print(forecasts[key][:5])
    <span class="keyword">else</span>:
        print(<span class="string">f"\n{files_info[key]}: No forecast values available"</span>)
        </code></pre>
    </div>
</body>
</html>